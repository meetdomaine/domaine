---
import { Icon } from "astro-icon/components"
import AtomSanityImage from "../../../global/atoms/atom-sanityImage.astro"
import { replaceStringIcons } from "../../../global/utils/inline-icon-text"

const { heading, subheading, eyebrow, button, projects } = Astro.props

const iconText = replaceStringIcons(heading)

---
<section id="home-hero" class="home-hero" data-color-scheme="brand-02">
    <div class="section-content">
        <div class="section-text">
            {eyebrow && <p class="utility">{eyebrow}</p>}
            {heading && <h1 class=""><Fragment set:html={iconText}/></h1>}
            {subheading && <p class="caption">{subheading}</p>}
        </div>
        {button.text && button.url &&
            <a class={`button color-invert`} data-style="tertiary" href={button.url}>{button.text}<Icon name="arrow-diagonal" /></a>
        }
    </div>
    <div class="section-media">
        {projects.map((projectCard, i) => (
            <div class="project-card" data-index={i} data-project={projectCard.project.slug.current} style={`--index: ${i};`}>
                <AtomSanityImage 
                    sizes="50vw"
                    image={projectCard.image ? projectCard.image.image : projectCard.project.thumbnailMedia.image}
                />
            </div>
        ))}
    </div>
    <div id="three-canvas"></div>
</section>

<script>
    import { isMobileBreakpoint } from "../../../global/utils/check-device"
import { fadeUp, gsap, addParallax } from "../../../global/utils/gsap"

    import { 
        Scene,
        PerspectiveCamera,
        WebGLRenderer,
        PlaneGeometry,
        MeshBasicMaterial,
        Mesh,
        Group,
        TextureLoader,
        DoubleSide,
        Vector3,
        LinearSRGBColorSpace,
        SRGBColorSpace,
    } from 'three'

    let renderer, scene, camera, imageGroup, meshPositions

    // DOM Elements
    const section = document.getElementById('home-hero')
    const canvas = section.querySelector('#three-canvas')
    const projectCards = section.querySelectorAll('.project-card')
    let container = section.getBoundingClientRect()

    const _cameraDistance = 500
    let cameraFOV = Math.atan( container.height / 2 / _cameraDistance ) * 2 * (180 / Math.PI)

    const animate = () => {
        renderer.render( scene, camera );

        // imageGroup.rotation.x += 0.01
    }

    const animateLoad = () => {

        const _spreadFactor = 0.3
        const _maxDepth = 300
        const _parallaxFactor = 50

        const animTimeline = gsap.timeline({ defaults: { duration: 2, ease: "cubic"}})
        animTimeline.from(imageGroup.position, {
            y: -container.height,
        })
        animTimeline.to(imageGroup.rotation, {
            x: Math.PI * 2,
            ease: 'power4.inOut'
        }, "<+=0.0")

        for ( let i = 0; i < meshPositions.length; i++) {
            animTimeline.to(meshPositions[i], {
                x: Math.sin( Math.PI * i / meshPositions.length * 2 ) * window.innerWidth * _spreadFactor,
                y: Math.cos( Math.PI * i / meshPositions.length * 2 ) * window.innerHeight * _spreadFactor,
                z: `random(-${_maxDepth / 2}, ${_maxDepth / 2})`,
            }, i === 0 ? "<+=0.8" : "<+=0.05")
        }

        if (!isMobileBreakpoint) {
            window.addEventListener("mousemove", (e) => {
                gsap.to(camera.position, {
                    x: e.clientX / window.innerWidth * _parallaxFactor,
                    y: - e.clientY / window.innerHeight * _parallaxFactor,
                    ease: 'cubic',
                    duration: 1.2
                })
            })
        }
    }

    const initImages = async () => {

        imageGroup = new Group()
        imageGroup.position.y = 0
        const loader = new TextureLoader()

        const texturePromises = []

        projectCards.forEach((card, i) => {

            const _width = 100
            const _subdivisions = 20
            const _stackDistance = 20
            const _projectCount = projectCards.length
            
            texturePromises.push( new Promise((resolve, reject) => {
                const image = card.querySelector('img')
                const imageSrc = image.currentSrc

                const imageRect = image.getBoundingClientRect()
                const imageRatio = imageRect.width / imageRect.height

                loader.load(imageSrc, (image) => {
                    // image.colorSpace = SRGBColorSpace
                    image.colorSpace = LinearSRGBColorSpace
                    const geometry = new PlaneGeometry(_width, _width / imageRatio, _subdivisions, _subdivisions)
                    const material = new MeshBasicMaterial({
                        map: image,
                        side: DoubleSide,
                    })
                    const mesh = new Mesh(geometry, material)

                    const startPoint = (_projectCount * _stackDistance) / 2 * -1

                    mesh.position.z = startPoint + _stackDistance * i 

                    imageGroup.add(mesh)
                    resolve(mesh)
                })
            }))
        })

        Promise.all(texturePromises).then((meshes) => {
            meshPositions = meshes.map((mesh) => mesh.position)
            scene.add(imageGroup)
            animateLoad()
        })

    }


    const initScene = () => {
        scene = new Scene();

        camera = new PerspectiveCamera( cameraFOV, container.width / container.height, 0.1, 1000 );
        camera.position.z = _cameraDistance

        renderer = new WebGLRenderer({ antialias: true, alpha: true });
        renderer.setAnimationLoop( animate );
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize( container.width, container.height );
        renderer.colorSpace = LinearSRGBColorSpace

        canvas.appendChild( renderer.domElement );

        initImages()
    }

    const handleResize = () => {
        container = section.getBoundingClientRect()
        // cameraFOV = Math.atan( container.height / 2 / _cameraDistance ) * 2 * (180 / Math.PI)
        renderer.setSize( container.width, container.height );
        camera.fov = cameraFOV
        camera.aspect = container.width / container.height
        camera.updateProjectionMatrix();
    }

    window.addEventListener("preload:complete", () => {
        initScene()
    })

    window.addEventListener("resize", handleResize)
</script>

<style>

    .home-hero {
        position: relative;
        z-index: 1;
        padding-inline: var(--page-margin);
        min-height: 95svh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow: hidden;
    }

    .section-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--space-md);
        position: relative;
        z-index: 1;
    }

    .section-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        max-width: 50rem;
        gap: var(--space-sm);
    }

    .section-media {
        position: absolute;
        inset: 0;
        max-height: 100%;
        z-index: 0;
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: var(--space-lg);
        padding: var(--space-lg);
    }

    .project-card {
        align-content: center;
        opacity: 0;
    }

    #three-canvas {
        position: absolute;
        inset: 0;
    }
</style>