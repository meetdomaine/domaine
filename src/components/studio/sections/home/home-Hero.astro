---
import { Icon } from "astro-icon/components"
import AtomSanityImage from "../../../global/atoms/atom-sanityImage.astro"
import { replaceStringIcons } from "../../../global/utils/inline-icon-text"

const { heading, subheading, eyebrow, button, projects } = Astro.props

const iconText = replaceStringIcons(heading)

---
<section id="home-hero" class="home-hero" data-color-scheme="brand-02" data-link-hover="false">
    <div class="section-content">
        <div class="section-text h1">
            {eyebrow && <p class="utility">{eyebrow}</p>}
            {heading && <h1 class=""><Fragment set:html={iconText}/></h1>}
            {subheading && <p class="caption">{subheading}</p>}
        </div>
        {button.text && button.url &&
            <a class={`button color-invert`} data-style="tertiary" href={button.url}>{button.text}<Icon name="arrow-diagonal" /></a>
        }
    </div>
    <div class="section-media">
        {projects.map((projectCard, i) => (
            <div 
                class="project-card" 
                data-index={i} 
                data-project={projectCard.project.slug.current} 
                style={`--index: ${i}; --random-seed: ${Math.random()};`}
            >
                {/* <div 
                    class="project-info caption"
                    data-color-scheme="glass-dark"
                >
                    <Icon name="arrow-diagonal" />
                    {projectCard.project.title}
                </div> */}
                <AtomSanityImage 
                    sizes="50vw"
                    image={projectCard.image ? projectCard.image.image : projectCard.project.thumbnailMedia.image}
                />
            </div>
        ))}
    </div>
    <div id="three-canvas"></div>
</section>

<script>
    const section: any = document.getElementById('home-hero')
    const projectCards = section.querySelectorAll('.project-card')
    let container = section.getBoundingClientRect()

    let mouseX = 0
    let mouseY = 0

    const updateVariables = () => {
        section.style = `
            --image-count: ${projectCards.length};
            --mouseX: ${mouseX}; 
            --mouseY: ${mouseY};
        `
    }

    window.addEventListener("mousemove", (e) => {
        mouseX = (e.clientX - container.left) / container.width
        mouseY = (e.clientY - container.top) / container.height
        updateVariables()
    })

    updateVariables()

    window.addEventListener("preload:complete", () => {
        
    })

</script>

<!-- <script>
    import { isMobileBreakpoint } from "../../../global/utils/check-device"
    import { fadeUp, gsap, addParallax } from "../../../global/utils/gsap"

    import { 
        Scene,
        PerspectiveCamera,
        WebGLRenderer,
        PlaneGeometry,
        MeshBasicMaterial,
        Mesh,
        Group,
        TextureLoader,
        DoubleSide,
        Vector2,
        Vector3,
        LinearSRGBColorSpace,
        SRGBColorSpace,
        Raycaster,
    } from 'three'

    let renderer, scene, camera, imageGroup, meshPositions

    // DOM Elements
    const section = document.getElementById('home-hero')
    const canvas = section.querySelector('#three-canvas')
    const projectCards = section.querySelectorAll('.project-card')
    let container = section.getBoundingClientRect()

    // Camera Settings
    const _cameraDistance = 500
    const _parallaxFactor = 0.1
    // const _parallaxFactor = 50
    let cameraFOV = Math.atan( container.height / 2 / _cameraDistance ) * 2 * (180 / Math.PI)

    // Raycaster
    const raycaster = new Raycaster()
    const mousePosition = new Vector2()
    let raycasterEnabled = false

    const animate = () => {
        
        gsap.to(imageGroup.rotation, {
            x: - Math.PI * mousePosition.y * _parallaxFactor,
            y: Math.PI * mousePosition.x * _parallaxFactor
        })

        // gsap.to(camera.position, {
        //     x: mousePosition.x * _parallaxFactor,
        //     y: mousePosition.y * _parallaxFactor,
        //     ease: 'cubic',
        //     duration: 1.2
        // })

        if (raycasterEnabled) {
            
            raycaster.setFromCamera( mousePosition, camera );
            const intersects = raycaster.intersectObjects( imageGroup.children );

            if (intersects.length <= 0) {
                section.dataset.linkHover = "false"
            } else {
                section.dataset.linkHover = "true"
                for ( let i = 0; i < intersects.length; i ++ ) {
                    console.log(intersects[i])
                    intersects[ i ].object.material.color.set( 0xff0000 );
                }
            }

        }

        renderer.render( scene, camera );
    }

    const animateLoad = () => {

        const _spreadFactor = 0.3
        const _maxDepth = 300

        const animTimeline = gsap.timeline({ defaults: { duration: 2, ease: "cubic"}})
        animTimeline.from(imageGroup.position, {
            y: -container.height,
        })
        animTimeline.to(imageGroup.rotation, {
            x: Math.PI * 2,
            ease: 'power4.inOut',
            onComplete: () => { raycasterEnabled = true }
        }, "<+=0.0")

        for ( let i = 0; i < meshPositions.length; i++) {
            animTimeline.to(meshPositions[i], {
                x: Math.sin( Math.PI * i / meshPositions.length * 2 ) * window.innerWidth * _spreadFactor,
                y: Math.cos( Math.PI * i / meshPositions.length * 2 ) * window.innerHeight * _spreadFactor,
                z: `random(-${_maxDepth / 2}, ${_maxDepth / 2})`,
            }, i === 0 ? "<+=0.8" : "<+=0.05")
        }

        if (!isMobileBreakpoint) {
            window.addEventListener("mousemove", (e) => {
                mousePosition.x = (e.clientX - container.left) / container.width * 2 - 1
                mousePosition.y = - (e.clientY - container.top) / container.height * 2  + 1
            })
        }
    }

    const initImages = async () => {

        imageGroup = new Group()
        imageGroup.position.y = 0
        const loader = new TextureLoader()

        const texturePromises = []

        projectCards.forEach((card, i) => {

            const _width = 100
            const _subdivisions = 20
            const _stackDistance = 20
            const _projectCount = projectCards.length
            
            texturePromises.push( new Promise((resolve, reject) => {
                const image = card.querySelector('img')
                const imageSrc = image.currentSrc

                const imageRect = image.getBoundingClientRect()
                const imageRatio = imageRect.width / imageRect.height

                loader.load(imageSrc, (image) => {
                    image.colorSpace = SRGBColorSpace
                    // image.colorSpace = LinearSRGBColorSpace
                    const geometry = new PlaneGeometry(_width, _width / imageRatio, _subdivisions, _subdivisions)
                    const material = new MeshBasicMaterial({
                        map: image,
                        side: DoubleSide,
                    })
                    const mesh = new Mesh(geometry, material)

                    const startPoint = (_projectCount * _stackDistance) / 2 * -1

                    mesh.position.z = startPoint + _stackDistance * i 

                    imageGroup.add(mesh)
                    resolve(mesh)
                })
            }))
        })

        Promise.all(texturePromises).then((meshes) => {
            meshPositions = meshes.map((mesh) => mesh.position)
            scene.add(imageGroup)
            animateLoad()
        })

    }


    const initScene = () => {
        scene = new Scene();

        camera = new PerspectiveCamera( cameraFOV, container.width / container.height, 0.1, 1000 );
        camera.position.z = _cameraDistance

        renderer = new WebGLRenderer({ antialias: true, alpha: true });
        renderer.setAnimationLoop( animate );
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize( container.width, container.height );
        renderer.colorSpace = SRGBColorSpace
        // renderer.colorSpace = LinearSRGBColorSpace

        canvas.appendChild( renderer.domElement );

        initImages()
    }

    const handleResize = () => {
        container = section.getBoundingClientRect()
        renderer.setSize( container.width, container.height );
        camera.fov = cameraFOV
        camera.aspect = container.width / container.height
        camera.updateProjectionMatrix();
    }

    window.addEventListener("preload:complete", () => {
        initScene()
    })

    window.addEventListener("resize", handleResize)
</script> -->

<style>

    .home-hero {
        position: relative;
        z-index: 1;
        /* padding-inline: var(--page-margin); */
        min-height: 95svh;
        display: flex;
        flex-direction: column;
        justify-content: stretch;
        align-items: stretch;
        overflow: hidden;
    }

    .home-hero[data-link-hover="true"] {
        cursor: pointer;
    }

    .section-content {
        position: absolute;
        top: 50%;
        left: 50%;
        translate: -50% -50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--space-md);
        /* position: relative; */
        z-index: 1;
    }

    .section-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        /* max-width: 60em; */
        gap: var(--space-sm);
    }

    .section-media {
        --depth: 400px;
        --parallax-factor: 20deg;
        --spread-factor: 0.75;
        position: relative;
        flex: 1 0 100%;
        z-index: 0;
        padding: var(--space-lg);
        perspective: var(--depth);
        transform: rotateX(calc( var(--mouseY) * var(--parallax-factor) * 2 - var(--parallax-factor) )) rotateY(calc( var(--mouseX) * var(--parallax-factor) * 2 - var(--parallax-factor) )) translateZ(calc(var(--depth) / 2 * -1));
        transform-style: preserve-3d;
        transition: transform var(--anim-md);
    }



    .project-card {
        --index-of-total: calc(var(--index) / var(--image-count));
        position: absolute;
        left: calc( 50% + sin(pi * 2 * var(--index-of-total)) * 50% * var(--spread-factor));
        top: calc( 50% - cos( pi * 2 * var(--index-of-total)) * 50% * var(--spread-factor));
        transform: translate3d(-50%, -50%, calc( (var(--depth) * var(--random-seed) - var(--depth) / 2) ) );
        transform-origin: center center;
        width: 12%;
        border-radius: var(--radius-sm);
        overflow: hidden;
    }

    .project-card:hover {
        opacity: 0.2;
    }

    .project-info {
        /* position: absolute;
        left: calc( 50% + sin(pi * 2 * var(--index-of-total)) * 50% * var(--spread-factor));
        top: calc( 50% - cos( pi * 2 * var(--index-of-total)) * 50% * var(--spread-factor));
        transform: translate3d(-50%, -50%, calc( (var(--depth) * var(--random-seed) - var(--depth) / 2) ) ); */
    }

    /* #three-canvas {
        position: absolute;
        inset: 0;
    } */
</style>